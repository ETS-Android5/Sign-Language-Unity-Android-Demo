// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAIN
package com.unity3d.player;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.PixelFormat;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.SystemClock;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.os.Process;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.iflytek.cloud.ErrorCode;
import com.iflytek.cloud.InitListener;
import com.iflytek.cloud.RecognizerListener;
import com.iflytek.cloud.RecognizerResult;
import com.iflytek.cloud.SpeechConstant;
import com.iflytek.cloud.SpeechError;
import com.iflytek.cloud.SpeechRecognizer;
import com.iflytek.cloud.SpeechUtility;
import com.iflytek.cloud.ui.RecognizerDialog;
import com.iflytek.cloud.ui.RecognizerDialogListener;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.util.HashMap;
import java.util.LinkedHashMap;

public class UnityPlayerActivity extends Activity implements IUnityPlayerLifecycleEvents
{
    public static UnityPlayerActivity currentActivity=null;
    private EditText textView;
    private SpeechRecognizer speechRecognizer;
    private RecognizerDialog recognizerDialog;
    private boolean isShowDialog = true;
    private SharedPreferences sharedPreferences;
    private HashMap<String, String> hashMap = new LinkedHashMap<String, String>();
    private String mEngineType = null;
    private int ret = 0;
    private Toast toast;

    protected UnityPlayer mUnityPlayer; // don't change the name of this variable; referenced from native code
    private Button button;
    private LinearLayout splash;
    private LinearLayout linearLayout;
    private static  final int STOPSPLASH = 0 ;
    private static  final long SPLASHTIME = 1000;

    @SuppressLint("HandlerLeak")
    private Handler splashHandler = new Handler()
    {
        public void handleMessage(Message msg)
        {
            switch (msg.what)
            {
                case STOPSPLASH:
                    SystemClock.sleep(2800);
                    splash.setVisibility(View.GONE);
                    break;
            }
            super.handleMessage(msg);
        }
    };
    // Override this in your custom UnityPlayerActivity to tweak the command line arguments passed to the Unity Android Player
    // The command line arguments are passed as a string, separated by spaces
    // UnityPlayerActivity calls this from 'onCreate'
    // Supported: -force-gles20, -force-gles30, -force-gles31, -force-gles31aep, -force-gles32, -force-gles, -force-vulkan
    // See https://docs.unity3d.com/Manual/CommandLineArguments.html
    // @param cmdLine the current command line arguments, may be null
    // @return the modified command line string or null
    protected String updateUnityCommandLineArguments(String cmdLine)
    {
        return cmdLine;
    }

    // Setup activity layout
    @Override protected void onCreate(Bundle savedInstanceState)
    {
        currentActivity=this;
        //getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra("unity"));
        getIntent().putExtra("unity", cmdLine);

        mUnityPlayer = new UnityPlayer(this);
        linearLayout=findViewById(R.id.linearLayout);
        button = (Button) findViewById(R.id.button);
        linearLayout.addView(mUnityPlayer);
        mUnityPlayer.requestFocus();
        splash = (LinearLayout)findViewById(R.id.splashscreen);


        Log.e("classname",UnityPlayerActivity.class.getName());
        init();
        initData();
    }

    public void initData()
    {
        SpeechUtility.createUtility(UnityPlayerActivity.this, SpeechConstant.APPID + "=5db11472");
        speechRecognizer = SpeechRecognizer.createRecognizer(UnityPlayerActivity.this, initListener);
        recognizerDialog = new RecognizerDialog(UnityPlayerActivity.this, initListener);
        sharedPreferences = getSharedPreferences(UnityPlayerActivity.this.getPackageName(), Context.MODE_PRIVATE);
        toast = Toast.makeText(UnityPlayerActivity.this, "", Toast.LENGTH_SHORT);
        mEngineType = SpeechConstant.TYPE_CLOUD;
    }

    public void init()
    {
        textView = (EditText) findViewById(R.id.editText);
        Message msg = new Message();
        msg.what = STOPSPLASH;
        splashHandler.sendMessageDelayed(msg,SPLASHTIME);
        /*button.setOnClickListener(new View.OnClickListener()
        {
            @Override
            public void onClick(View v)
            {
                mUnityPlayer.UnitySendMessage("CharacterHandler","PlayAnim","你好");
            }
        });*/
    }
    // When Unity player unloaded move task to background
    @Override public void onUnityPlayerUnloaded() {
        moveTaskToBack(true);
    }

    // When Unity player quited kill process
    @Override public void onUnityPlayerQuitted() {
        Process.killProcess(Process.myPid());
    }

    @Override protected void onNewIntent(Intent intent)
    {
        // To support deep linking, we need to make sure that the client can get access to
        // the last sent intent. The clients access this through a JNI api that allows them
        // to get the intent set on launch. To update that after launch we have to manually
        // replace the intent with the one caught here.
        setIntent(intent);
        mUnityPlayer.newIntent(intent);
    }

    // Quit Unity
    @Override protected void onDestroy ()
    {
        mUnityPlayer.destroy();
        super.onDestroy();
    }

    // Pause Unity
    @Override protected void onPause()
    {
        super.onPause();
        mUnityPlayer.pause();
    }

    // Resume Unity
    @Override protected void onResume()
    {
        super.onResume();
        mUnityPlayer.resume();
    }

    // Low Memory Unity
    @Override public void onLowMemory()
    {
        super.onLowMemory();
        mUnityPlayer.lowMemory();
    }

    // Trim Memory Unity
    @Override public void onTrimMemory(int level)
    {
        super.onTrimMemory(level);
        if (level == TRIM_MEMORY_RUNNING_CRITICAL)
        {
            mUnityPlayer.lowMemory();
        }
    }

    // This ensures the layout will be correct.
    @Override public void onConfigurationChanged(Configuration newConfig)
    {
        super.onConfigurationChanged(newConfig);
        mUnityPlayer.configurationChanged(newConfig);
    }

    // Notify Unity of the focus change.
    @Override public void onWindowFocusChanged(boolean hasFocus)
    {
        super.onWindowFocusChanged(hasFocus);
        mUnityPlayer.windowFocusChanged(hasFocus);
    }

    // For some reason the multiple keyevent type is not supported by the ndk.
    // Force event injection by overriding dispatchKeyEvent().
    @Override public boolean dispatchKeyEvent(KeyEvent event)
    {
        if (event.getAction() == KeyEvent.ACTION_MULTIPLE)
            return mUnityPlayer.injectEvent(event);
        return super.dispatchKeyEvent(event);
    }

    // Pass any events not handled by (unfocused) views straight to UnityPlayer
    @Override public boolean onKeyUp(int keyCode, KeyEvent event)     { return mUnityPlayer.injectEvent(event); }
    @Override public boolean onKeyDown(int keyCode, KeyEvent event)   { return mUnityPlayer.injectEvent(event); }
    @Override public boolean onTouchEvent(MotionEvent event)          { return mUnityPlayer.injectEvent(event); }
    /*API12*/ public boolean onGenericMotionEvent(MotionEvent event)  { return mUnityPlayer.injectEvent(event); }


    //语音读写
    public void start(View view)
    {
        textView.setText("");
        hashMap.clear();
        setParams();

        if (isShowDialog)
        {
            recognizerDialog.setListener(dialogListener);
            recognizerDialog.show();
            TextView txt = (TextView)recognizerDialog.getWindow().getDecorView().findViewWithTag("textlink");
            txt.setText("");
        }
        else
        {
            ret = speechRecognizer.startListening(recognizerListener);
            if (ret != ErrorCode.SUCCESS)
            {
                Log.e("tag", "听写失败,错误码" + ret);
            }
        }

    }

    public void stop(View view)
    {
        Toast.makeText(UnityPlayerActivity.this, "停止听写", Toast.LENGTH_SHORT).show();
        if (isShowDialog)
        {
            recognizerDialog.dismiss();
        }
        else
        {
            speechRecognizer.stopListening();
        }
    }

    private InitListener initListener = new InitListener()
    {
        @Override
        public void onInit(int i)
        {
            if (i != ErrorCode.SUCCESS)
            {
                Log.e("tag", "初始化失败，错误码" + i);
            }
        }
    };

    private RecognizerListener recognizerListener = new RecognizerListener()
    {
        @Override
        public void onVolumeChanged(final int i, byte[] bytes)
        {
            Log.e("tag", "返回数据大小" + bytes.length);
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    toast.setText("当前音量" + i);
                }
            });
        }
        @Override
        public void onBeginOfSpeech()
        {
            Log.e("tag", "开始说话");
        }

        @Override
        public void onEndOfSpeech()
        {
            Log.e("tag", "结束说话");
        }

        @Override
        public void onResult(com.iflytek.cloud.RecognizerResult recognizerResult, boolean b)
        {
            if (recognizerResult != null)
            {
                Log.e("tag", "听写结果：" + recognizerResult.getResultString());
                printResult(recognizerResult);
            }
        }

        @Override
        public void onError(SpeechError speechError)
        {
            Log.e("tag", "错误信息" + speechError.getPlainDescription(true));

        }

        @Override
        public void onEvent(int i, int i1, int i2, Bundle bundle)
        {
            // 以下代码用于获取与云端的会话id，当业务出错时将会话id提供给技术支持人员，可用于查询会话日志，定位出错原因
            // 若使用本地能力，会话id为null
            //  if (SpeechEvent.EVENT_SESSION_ID == eventType) {
            //      String sid = obj.getString(SpeechEvent.KEY_EVENT_SESSION_ID);
            //      Log.d(TAG, "session id =" + sid);
            //  }
        }
    };


    //有UI监听器
    private RecognizerDialogListener dialogListener = new RecognizerDialogListener()
    {

        @Override
        public void onResult(RecognizerResult recognizerResult, boolean b)
        {
            if(recognizerResult!=null)
            {
                Log.e("tag", "听写结果：" + recognizerResult.getResultString());
                printResult(recognizerResult);
            }
        }

        @Override
        public void onError(SpeechError speechError)
        {
            Log.e("tag", speechError.getPlainDescription(true));
        }
    };

    //输出结果，将返回的json字段解析并在textVie中显示
    private void printResult(RecognizerResult results)
    {
        StringBuffer strBuffer = new StringBuffer();

        String sn = null;
        // 读取json结果中的sn字段
        try
        {
            JSONTokener tokener = new JSONTokener(results.getResultString());
            JSONObject resultJson = new JSONObject(tokener);
            JSONArray words = resultJson.getJSONArray("ws");
            for (int i=0;i<words.length();i++)
            {
                JSONArray items = words.getJSONObject(i).getJSONArray("cw");
                JSONObject obj = items.getJSONObject(0);
                strBuffer.append(obj.getString("w"));
            }
            sn = resultJson.optString("sn");
        }
        catch (JSONException e)
        {
            e.printStackTrace();
        }

        hashMap.put(sn, strBuffer.toString());

        StringBuffer resultBuffer = new StringBuffer();
        for (String key : hashMap.keySet())
        {
            resultBuffer.append(hashMap.get(key));
        }

        textView.setText(resultBuffer.toString());
        String result = textView.getText().toString();
        mUnityPlayer.UnitySendMessage("CharacterHandler","PlayAnim",result);
    }
    public void ShowMessageFromUnity()
    {
        runOnUiThread(new Runnable()
        {
            @Override
            public void run()
            {
                Toast.makeText(UnityPlayerActivity.this,"动画完善中",Toast.LENGTH_SHORT).show();
            }
        });

    }
    private void setParams()
    {
        //清空参数
        speechRecognizer.setParameter(SpeechConstant.PARAMS, null);
        //设置引擎
        speechRecognizer.setParameter(SpeechConstant.ENGINE_TYPE, mEngineType);
        //设置返回数据类型
        speechRecognizer.setParameter(SpeechConstant.RESULT_TYPE, "json");
        //设置中文 普通话
        speechRecognizer.setParameter(SpeechConstant.LANGUAGE, "zh_cn");
        speechRecognizer.setParameter(SpeechConstant.ACCENT, "mandarin");

        // 设置语音前端点:静音超时时间，即用户多长时间不说话则当做超时处理
        speechRecognizer.setParameter(SpeechConstant.VAD_BOS,
                sharedPreferences.getString("iat_vadbos_preference", "4000"));

        // 设置语音后端点:后端点静音检测时间，即用户停止说话多长时间内即认为不再输入， 自动停止录音
        speechRecognizer.setParameter(SpeechConstant.VAD_EOS,
                sharedPreferences.getString("iat_vadeos_preference", "1000"));

        // 设置标点符号,设置为"0"返回结果无标点,设置为"1"返回结果有标点
        speechRecognizer.setParameter(SpeechConstant.ASR_PTT,
                sharedPreferences.getString("iat_punc_preference", "0"));

        // 设置音频保存路径，保存音频格式支持pcm、wav，设置路径为sd卡请注意WRITE_EXTERNAL_STORAGE权限
        // 注：AUDIO_FORMAT参数语记需要更新版本才能生效
        speechRecognizer.setParameter(SpeechConstant.AUDIO_FORMAT, "wav");
        speechRecognizer.setParameter(SpeechConstant.ASR_AUDIO_PATH, Environment.getExternalStorageDirectory() + "/msc/iat.wav");

    }
}
